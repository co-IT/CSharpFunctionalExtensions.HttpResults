using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CSharpFunctionalExtensions.HttpResults.Generators.Builders;

public abstract class ClassBuilder
{
  private const string MapMethodName = "Map";
  private readonly List<ClassDeclarationSyntax> _mapperClasses;
  private readonly HashSet<string> _requiredNamespaces;

  protected ClassBuilder(HashSet<string> requiredNamespaces, List<ClassDeclarationSyntax> mapperClasses)
  {
    _requiredNamespaces = requiredNamespaces;
    _mapperClasses = mapperClasses;
  }

  private static string DefaultUsings =>
    """
      using CSharpFunctionalExtensions;
      using IResult = Microsoft.AspNetCore.Http.IResult;
      using Microsoft.AspNetCore.Http.HttpResults;
      using Microsoft.AspNetCore.Http;
      using Microsoft.AspNetCore.Mvc;
      using Microsoft.Net.Http.Headers;
      using System.Text;
      """;

  public string SourceFileName => $"{ClassName}.g.cs";

  protected abstract string ClassName { get; }
  protected abstract string ClassSummary { get; }
  internal abstract List<IGenerateMethods> MethodGenerators { get; }

  public string Build()
  {
    var sourceBuilder = new StringBuilder();

    sourceBuilder.AppendLine("// <auto-generated/>");
    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine("#nullable enable");
    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine(DefaultUsings);

    _requiredNamespaces
      .Where(@namespace => !@namespace.StartsWith("global"))
      .Distinct()
      .Select(@namespace => $"using {@namespace};")
      .ToList()
      .ForEach(@using => sourceBuilder.AppendLine(@using));

    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine(ClassSummary);

    sourceBuilder.AppendLine($"public static partial class {ClassName} {{");
    sourceBuilder.AppendLine();

    foreach (var mapperClass in _mapperClasses)
    {
      var mapperClassName = mapperClass.Identifier.Text;
      var mappingMethod = mapperClass
        .Members.OfType<MethodDeclarationSyntax>()
        .FirstOrDefault(method => method.Identifier.Text == MapMethodName);

      if (mappingMethod == null)
        throw new ArgumentException($"Mapping method in class {mapperClassName} not found.");

      if (mappingMethod.ParameterList.Parameters.Count != 1)
        throw new ArgumentException($"Mapping method in class {mapperClassName} must have exactly one parameter.");

      var resultErrorType = mappingMethod.ParameterList.Parameters[0].Type!.ToString();
      var httpResultType = mappingMethod.ReturnType.ToString();

      foreach (var methodGenerator in MethodGenerators)
      {
        sourceBuilder.AppendLine(methodGenerator.Generate(mapperClassName, resultErrorType, httpResultType));
        sourceBuilder.AppendLine();
      }
    }

    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine("}");

    return sourceBuilder.ToString();
  }
}
