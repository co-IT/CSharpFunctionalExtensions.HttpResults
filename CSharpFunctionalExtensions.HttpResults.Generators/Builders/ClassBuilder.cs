using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CSharpFunctionalExtensions.HttpResults.Generators.Builders;

public abstract class ClassBuilder
{
  private readonly List<ClassDeclarationSyntax> _mapperClasses;
  private readonly List<string> _requiredNamespaces;

  protected ClassBuilder(List<string> requiredNamespaces, List<ClassDeclarationSyntax> mapperClasses)
  {
    _requiredNamespaces = requiredNamespaces;
    _mapperClasses = mapperClasses;
  }

  private static string DefaultUsings =>
    """
      using CSharpFunctionalExtensions;
      using IResult = Microsoft.AspNetCore.Http.IResult;
      using Microsoft.AspNetCore.Http.HttpResults;
      using Microsoft.AspNetCore.Http;
      using Microsoft.AspNetCore.Mvc;
      using Microsoft.Net.Http.Headers;
      """;

  public string SourceFileName => $"{ClassName}.g.cs";

  protected abstract string ClassName { get; }
  protected abstract string ClassSummary { get; }
  internal abstract List<IGenerateMethods> MethodGenerators { get; }

  public string Build()
  {
    var sourceBuilder = new StringBuilder();

    sourceBuilder.AppendLine("// <auto-generated/>");
    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine("#nullable enable");
    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine(DefaultUsings);

    _requiredNamespaces
      .Where(@namespace => !@namespace.StartsWith("global"))
      .Distinct()
      .Select(@namespace => $"using {@namespace};")
      .ToList()
      .ForEach(@using => sourceBuilder.AppendLine(@using));

    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine(ClassSummary);

    sourceBuilder.AppendLine($"public static partial class {ClassName} {{");
    sourceBuilder.AppendLine();

    foreach (var mapperClass in _mapperClasses)
    {
      var mapperClassName = mapperClass.Identifier.Text;
      var mappingProperty =
        mapperClass.Members.FirstOrDefault(member => (member as PropertyDeclarationSyntax)?.Identifier.Text == "Map")
        as PropertyDeclarationSyntax;
      var mappingTypes = (mappingProperty?.Type as GenericNameSyntax)
        ?.TypeArgumentList.Arguments.Select(type => type.ToString())
        .ToArray();

      if (mappingTypes is null || mappingTypes.Length != 2)
        throw new ArgumentException(
          $"Mapping property in class {mapperClassName} must have exactly two generic arguments."
        );

      var resultErrorType = mappingTypes[0];
      var httpResultType = mappingTypes[1];

      foreach (var methodGenerator in MethodGenerators)
        sourceBuilder.AppendLine(methodGenerator.Generate(mapperClassName, resultErrorType, httpResultType));
    }

    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine("}");

    return sourceBuilder.ToString();
  }
}
