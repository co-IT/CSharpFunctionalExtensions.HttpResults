using System.Text;
using CSharpFunctionalExtensions.HttpResults.Generators.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CSharpFunctionalExtensions.HttpResults.Generators.Builders;

public abstract class ClassBuilder
{
  private const string MapMethodName = "Map";
  private readonly Compilation? _compilation;
  private readonly List<ClassDeclarationSyntax> _mapperClasses;

  protected ClassBuilder(List<ClassDeclarationSyntax> mapperClasses, Compilation? compilation = null)
  {
    _mapperClasses = mapperClasses;
    _compilation = compilation;
  }

  private static string DefaultUsings =>
    """
      using CSharpFunctionalExtensions;
      using Microsoft.AspNetCore.Http.HttpResults;
      using Microsoft.AspNetCore.Http;
      using Microsoft.AspNetCore.Mvc;
      using Microsoft.Net.Http.Headers;
      using System.Text;
      using IResult = Microsoft.AspNetCore.Http.IResult;
      """;

  public string SourceFileName => $"{ClassName}.g.cs";

  protected abstract string ClassName { get; }
  protected abstract string ClassSummary { get; }
  internal abstract List<IGenerateMethods> MethodGenerators { get; }

  public string Build()
  {
    var sourceBuilder = new StringBuilder();

    sourceBuilder.AppendLine("// <auto-generated/>");
    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine("#nullable enable");
    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine(DefaultUsings);

    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine(ClassSummary);

    sourceBuilder.AppendLine($"public static partial class {ClassName} {{");
    sourceBuilder.AppendLine();

    foreach (var mapperClass in _mapperClasses)
    {
      var mapperClassName = mapperClass.Identifier.Text;
      var mappingMethod = mapperClass
        .Members.OfType<MethodDeclarationSyntax>()
        .FirstOrDefault(method => method.Identifier.Text == MapMethodName);

      if (mappingMethod == null)
        throw new ArgumentException($"Mapping method in class {mapperClassName} not found.");

      if (mappingMethod.ParameterList.Parameters.Count != 1)
        throw new ArgumentException($"Mapping method in class {mapperClassName} must have exactly one parameter.");

      var resultErrorType = GetFullyQualifiedTypeName(mapperClass, mappingMethod.ParameterList.Parameters[0].Type!);
      var httpResultType = mappingMethod.ReturnType!.ToString();

      foreach (var methodGenerator in MethodGenerators)
      {
        sourceBuilder.AppendLine(methodGenerator.Generate(mapperClassName, resultErrorType, httpResultType));
        sourceBuilder.AppendLine();
      }
    }

    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine("}");

    return sourceBuilder.ToString();
  }

  private string GetFullyQualifiedTypeName(ClassDeclarationSyntax mapperClass, TypeSyntax typeSyntax)
  {
    if (_compilation == null)
      return typeSyntax.ToString();

    var semanticModel = _compilation.GetSemanticModel(mapperClass.SyntaxTree);
    var typeInfo = semanticModel.GetTypeInfo(typeSyntax);

    if (typeInfo.Type == null)
      return typeSyntax.ToString();

    return TypeNameResolver.GetFullyQualifiedTypeName(typeInfo.Type);
  }
}
